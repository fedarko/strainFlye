import os
import pandas as pd
from strainflye import config
from strainflye.errors import ParameterError


def make_output_dir(output_dir):
    """Creates an output directory, if it doesn't already exist."""
    os.makedirs(output_dir, exist_ok=True)


def verify_contig_subset(child, parent, child_desc, parent_desc, exact=False):
    """Verifies that one set of contig names is a subset of another set.

    Parameters
    ----------
    child: set
        Set of contig names.

    parent: set
        Set of contig names.

    child_desc: str
        Human-readable description of the child set of contig names.

    parent_desc: str
        Human-readable description of the parent set of contig names.

    exact: bool
        If True, this makes the check stricter -- it now ensures that the two
        sets are identical (so parent must also be a subset of child).

    Returns
    -------
    None

    Raises
    ------
    ParameterError
        - If the child set is not a subset of the parent set.
        - If exact is True, and the parent set and child set are not identical.
        The resulting error message will include child_desc and parent_desc.
    """
    if not child.issubset(parent):
        raise ParameterError(
            f"All contigs in {child_desc} must also be contained in "
            f"{parent_desc}."
        )
    # Equivalently, we could check "exact and not parent.issubset(child)", but
    # I think this way of writing it is clearer
    if exact and parent != child:
        raise ParameterError(
            f"All contigs in {parent_desc} must also be contained in "
            f"{child_desc}."
        )


def verify_contig_lengths(fasta_name2len, bam_obj=None, bcf_obj=None):
    """Verifies that contig lengths from a FASTA file match other sources.

    The only required parameter is fasta_name2len. You can provide either both
    bam_obj and bcf_obj, or just one of them.

    Please note that we only check that the lengths match for contigs in the
    FASTA file (so if the BCF or BAM file contain contigs that aren't in the
    FASTA file, then these "extra" contigs will be implicitly ignored).

    Also, note that we assume that you've already verified that the *names* of
    the contigs match up between files -- if any of the FASTA contigs aren't
    in the BAM or BCF at all, then this will result in uncaught ugly errors.
    (Yeah, it would be most efficient to combine the names check in with
    this, but let's keep this simple for now...)

    Parameters
    ----------
    fasta_name2len: dict
        Maps contig names to lengths. Can be generated by
        fasta_utils.get_name2len().

    bcf_obj: pysam.VariantFile or None
        Object describing a BCF file, produced by pysam. In practice, you
        can get this from bcf_utils.parse_*_bcf(). We make the assumption that
        all contigs defined in the header of this file have the "length"
        attribute, and that this length attribute is not None; this should
        already have been enforced by bcf_utils.parse_*_bcf().

    bam_obj: pysam.AlignmentFile or None
        Object describing a BAM file, produced by pysam.

    Returns
    -------
    None

    Raises
    ------
    ParameterError
        If, for every contig in fasta_name2len, its length does not exactly
        match its corresponding length in bam_obj or in bcf_obj.

        If both bam_obj and bcf_obj are None.
    """
    chk_bam = bam_obj is not None
    chk_bcf = bcf_obj is not None

    if not chk_bam and not chk_bcf:
        raise ParameterError("Neither bam_obj nor bcf_obj is provided.")

    for contig in fasta_name2len:
        faslen = fasta_name2len[contig]

        # We could make the error message here fancier if needed (e.g. once we
        # see a mismatch in the BAM, then check the BCF also), but let's keep
        # this simple and easy for now
        if chk_bam:
            bamlen = bam_obj.get_reference_length(contig)
            if faslen != bamlen:
                raise ParameterError(
                    f"Contig {contig} has length {faslen:,} in the FASTA "
                    f"file, but length {bamlen:,} in the BAM file."
                )
        if chk_bcf:
            bcflen = bcf_obj.header.contigs[contig].length
            if faslen != bcflen:
                raise ParameterError(
                    f"Contig {contig} has length {faslen:,} in the FASTA "
                    f"file, but length {bcflen:,} in the BCF file."
                )


def load_and_sanity_check_diversity_indices(
    diversity_indices, min_num_contigs=1, min_num_di_columns=1
):
    """Loads and validates a file containing diversity index information.

    Parameters
    ----------
    diversity_indices: str
        Filepath to a TSV file containing diversity index information.
        Generated by "strainFlye call."

    min_num_contigs: int
        If the diversity index file contains less than this many contigs,
        we'll throw an error. (I guess you could set this to zero to
        effectively stop this check, but this should probably always be one,
        right?)

    min_num_di_columns: int
        If the diversity index file contains less than this many columns
        whose names begin with config.DI_PREF, we'll throw an error.

    Returns
    -------
    di: pd.DataFrame
        Represents the input diversity index file. The indices are contigs; the
        columns are, well, columns in the diversity index TSV file.
    """
    di = pd.read_csv(diversity_indices, sep="\t", index_col=0)

    if len(di.index) < min_num_contigs:
        raise ParameterError(
            f"Diversity indices file describes < {min_num_contigs:,} contigs."
        )

    if "Length" not in di.columns or "AverageCoverage" not in di.columns:
        raise ParameterError(
            'Diversity indices file must include the "Length" and '
            '"AverageCoverage" columns.'
        )

    num_di_cols = 0
    for col in di.columns:
        if col.startswith(config.DI_PREF):
            num_di_cols += 1
    if num_di_cols < min_num_di_columns:
        raise ParameterError(
            f"Diversity indices file describes < {min_num_di_columns:,} "
            "columns of diversity indices."
        )
    return di
